{
  "name": "index.js",
  "description": "Provides the foundational architecture of AJS, featuring a\nlightweight class system with inheritance and mixins, basic decorators,\nand a promise-based deferred implementation.",
  "features": [],
  "examples": [
    {
      "caption": "Class Definition with Static Members",
      "code": "import { base } from 'xajs/core'\n\nconst MyComponent = base.Class({\n$extends: BaseComponent,\n\n// Static properties and methods\n$static: {\ndefaultConfig: {\ntheme: 'light'\n},\ncreate(config) {\nreturn new this({ ...this.defaultConfig, ...config })\n}\n},\n\n// Constructor\n$ctor(config) {\nthis.$super() // Call parent constructor\nthis.config = config\nthis.state = { count: 0 }\n},\n\n// Instance methods\nincrement() {\nthis.state.count++\nthis.emit('change', this.state.count)\n}\n})"
    },
    {
      "caption": "Mixin and Deprecation",
      "code": "import { decorators } from 'xajs/core'\n\n// Define a mixin\nconst LoggerMixin = {\nlog(msg) {\nconsole.log(`[${this.constructor.name}] ${msg}`)\n}\n}\n\n// Apply mixin and deprecate old methods\n@decorators.mixin(LoggerMixin)\nclass MyService {\n@decorators.deprecate('Use newMethod() instead', { since: '2.0.0' })\noldMethod() {\nreturn this.newMethod()\n}\n\nnewMethod() {\nthis.log('Operation started')\nreturn this.processData()\n}\n}"
    },
    {
      "caption": "Async Operations with Deferred",
      "code": "import { base } from 'xajs/core'\n\nclass DataLoader {\nasync loadData(retryCount = 3) {\nconst deferred = new base.Deferred()\n\ntry {\n// Attempt to load data with retry\nfor (let i = 0; i < retryCount; i++) {\ntry {\nconst response = await fetch('/api/data')\nif (!response.ok) throw new Error('API Error')\nconst data = await response.json()\nreturn deferred.resolve(data)\n} catch (err) {\nif (i === retryCount - 1) throw err\nawait new Promise(r => setTimeout(r, 1000 * (i + 1)))\n}\n}\n} catch (err) {\ndeferred.reject(err)\n}\n\nreturn deferred\n.done() // Ensures unhandled rejections are thrown\n}\n\nisDataLoaded() {\nreturn this.loadData.isDone()\n}\n}"
    }
  ],
  "exports": [
    "base",
    "decorators"
  ],
  "related": [
    "."
  ],
  "see": [],
  "namespaces": {
    "ClassSystem": {
      "name": "ClassSystem",
      "properties": {
        "Class": {
          "type": "Function",
          "name": "Class",
          "description": "Base class factory with $extends, $ctor, and $static support"
        }
      }
    },
    "Decorators": {
      "name": "Decorators",
      "properties": {
        "mixin": {
          "type": "Function",
          "name": "mixin",
          "description": "Class decorator for mixin application"
        },
        "deprecate": {
          "type": "Function",
          "name": "deprecate",
          "description": "Method/property deprecation decorator with custom messages"
        }
      }
    },
    "Deferred": {
      "name": "Deferred",
      "properties": {
        "Deferred": {
          "type": "Function",
          "name": "Deferred",
          "description": "Promise wrapper with resolve/reject control"
        },
        "done": {
          "type": "Function",
          "name": "done",
          "description": "Final promise chain handler with error propagation"
        },
        "isDone": {
          "type": "Function",
          "name": "isDone",
          "description": "Promise state check for completion status"
        }
      }
    }
  }
}